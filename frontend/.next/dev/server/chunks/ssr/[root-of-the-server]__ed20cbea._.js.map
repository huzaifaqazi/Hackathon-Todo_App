{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///home/huzaifa/Hackathon/Todo-app/frontend/src/services/auth.ts"],"sourcesContent":["import axios from 'axios';\n\ninterface User {\n  id: string;\n  email: string;\n  first_name?: string;\n  last_name?: string;\n  is_active: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface LoginResponse {\n  success: boolean;\n  message: string;\n  data: {\n    user: User;\n    token: string;\n  };\n}\n\ninterface RegisterResponse {\n  success: boolean;\n  message: string;\n  data: {\n    user: User;\n  };\n}\n\ninterface GetUserResponse {\n  success: boolean;\n  data: {\n    user: User;\n  };\n}\n\nclass AuthService {\n  private apiUrl: string;\n\n  constructor() {\n    this.apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8002';\n  }\n\n  async login(email: string, password: string): Promise<LoginResponse> {\n    try {\n      // Check if we're in the browser (not server-side)\n      if (typeof window === 'undefined' || typeof localStorage === 'undefined') {\n        throw new Error('Not in browser environment');\n      }\n\n      const response = await axios.post(`${this.apiUrl}/api/v1/auth/login`, {\n        email,\n        password\n      });\n\n      if (response.data.success) {\n        // Store token in localStorage using consistent key\n        const token = response.data.data?.token;\n        if (token) {\n          localStorage.setItem('access_token', token);\n        }\n      }\n\n      return response.data;\n    } catch (error: any) {\n      console.error('Login error details:', error); // Log the full error for debugging\n\n      if (error.response) {\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        const errorMessage = error.response.data?.detail ||\n                           error.response.data?.message ||\n                           error.response.statusText ||\n                           'Login failed';\n        throw new Error(errorMessage);\n      } else if (error.request) {\n        // The request was made but no response was received\n        throw new Error('Network error: Unable to reach the server. Please check if the backend is running.');\n      } else {\n        // Something happened in setting up the request that triggered an Error\n        throw new Error(error.message || 'Login failed');\n      }\n    }\n  }\n\n  async register(userData: {\n    email: string;\n    password: string;\n    first_name?: string;\n    last_name?: string;\n  }): Promise<RegisterResponse> {\n    try {\n      const response = await axios.post(`${this.apiUrl}/api/v1/auth/register`, userData);\n      return response.data;\n    } catch (error: any) {\n      console.error('Registration error details:', error); // Log the full error for debugging\n\n      if (error.response) {\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        const errorMessage = error.response.data?.detail ||\n                           error.response.data?.message ||\n                           error.response.statusText ||\n                           'Registration failed';\n        throw new Error(errorMessage);\n      } else if (error.request) {\n        // The request was made but no response was received\n        throw new Error('Network error: Unable to reach the server. Please check if the backend is running.');\n      } else {\n        // Something happened in setting up the request that triggered an Error\n        throw new Error(error.message || 'Registration failed');\n      }\n    }\n  }\n\n  async logout(): Promise<{ success: boolean; message: string }> {\n    try {\n      // Check if we're in the browser (not server-side)\n      if (typeof window === 'undefined' || typeof localStorage === 'undefined') {\n        throw new Error('Not in browser environment');\n      }\n\n      const token = this.getTokenWithMigration();\n\n      if (!token) {\n        throw new Error('No token found');\n      }\n\n      const response = await axios.post(`${this.apiUrl}/api/v1/auth/logout`, {\n        token\n      }, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n\n      // Remove token from localStorage\n      localStorage.removeItem('access_token');\n\n      return response.data;\n    } catch (error: any) {\n      console.error('Logout error details:', error); // Log the full error for debugging\n\n      // Even if the server call fails, remove the token locally\n      if (typeof window !== 'undefined' && typeof localStorage !== 'undefined') {\n        localStorage.removeItem('access_token');\n      }\n\n      if (error.response) {\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        const errorMessage = error.response.data?.detail ||\n                           error.response.data?.message ||\n                           error.response.statusText ||\n                           'Logout failed';\n        throw new Error(errorMessage);\n      } else if (error.request) {\n        // The request was made but no response was received\n        throw new Error('Network error: Unable to reach the server. Please check if the backend is running.');\n      } else {\n        // Something happened in setting up the request that triggered an Error\n        throw new Error(error.message || 'Logout failed');\n      }\n    }\n  }\n\n  async getCurrentUser(): Promise<User> {\n    try {\n      // Check if we're in the browser (not server-side)\n      if (typeof window === 'undefined' || typeof localStorage === 'undefined') {\n        throw new Error('Not in browser environment');\n      }\n\n      const token = this.getTokenWithMigration();\n\n      if (!token) {\n        throw new Error('No token found');\n      }\n\n      const response = await axios.get(`${this.apiUrl}/api/v1/auth/me`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n\n      if (response.data.success) {\n        return response.data.data.user;\n      } else {\n        throw new Error('Failed to get user data');\n      }\n    } catch (error: any) {\n      console.error('Get current user error details:', error); // Log the full error for debugging\n\n      if (error.response) {\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        const errorMessage = error.response.data?.detail ||\n                           error.response.data?.message ||\n                           error.response.statusText ||\n                           'Failed to get user data';\n        throw new Error(errorMessage);\n      } else if (error.request) {\n        // The request was made but no response was received\n        throw new Error('Network error: Unable to reach the server. Please check if the backend is running.');\n      } else {\n        // Something happened in setting up the request that triggered an Error\n        throw new Error(error.message || 'Failed to get user data');\n      }\n    }\n  }\n\n  // Helper method to get token with migration support\n  private getTokenWithMigration(): string | null {\n    if (typeof window !== 'undefined' && typeof localStorage !== 'undefined') {\n      // First check for new token key\n      let token = localStorage.getItem('access_token');\n      if (!token) {\n        // Check for old token key and migrate it\n        const oldToken = localStorage.getItem('token');\n        if (oldToken) {\n          // Migrate old token to new key\n          localStorage.setItem('access_token', oldToken);\n          localStorage.removeItem('token'); // Clean up old key\n          token = oldToken;\n        }\n      }\n      return token;\n    }\n    return null;\n  }\n\n  isAuthenticated(): boolean {\n    const token = this.getTokenWithMigration();\n    return !!token;\n  }\n\n  getToken(): string | null {\n    return this.getTokenWithMigration();\n  }\n}\n\nexport default new AuthService();"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 194, "column": 0}, "map": {"version":3,"sources":["file:///home/huzaifa/Hackathon/Todo-app/frontend/src/context/AuthContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';\nimport authService from '../services/auth';\nimport { User } from '../types/user';\n\n// Define the shape of our auth context\ninterface AuthContextType {\n  user: User | null;\n  loading: boolean;\n  isAuthenticated: boolean;\n  login: (email: string, password: string) => Promise<void>;\n  register: (userData: {\n    email: string;\n    password: string;\n    first_name?: string;\n    last_name?: string;\n  }) => Promise<void>;\n  logout: () => Promise<void>;\n  getCurrentUser: () => Promise<void>;\n}\n\n// Create the context\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// Create the provider component\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);\n\n  // Check if user is authenticated on initial load\n  useEffect(() => {\n    const checkAuthStatus = async () => {\n      try {\n        if (authService.isAuthenticated()) {\n          await getCurrentUser();\n          setIsAuthenticated(true);\n        } else {\n          // If no token exists, explicitly set as not authenticated\n          setIsAuthenticated(false);\n        }\n      } catch (error) {\n        console.error('Auth check failed:', error);\n        // Clear any invalid token\n        localStorage.removeItem('access_token');\n        // Explicitly set as not authenticated after clearing invalid token\n        setIsAuthenticated(false);\n        setUser(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    checkAuthStatus();\n  }, []);\n\n  const login = async (email: string, password: string) => {\n    try {\n      const response = await authService.login(email, password);\n\n      if (response.success) {\n        setUser(response.data.user);\n        setIsAuthenticated(true);\n      } else {\n        throw new Error(response.message || 'Login failed');\n      }\n    } catch (error) {\n      // Ensure authentication state is properly reset on login failure\n      setUser(null);\n      setIsAuthenticated(false);\n      throw error;\n    }\n  };\n\n  const register = async (userData: {\n    email: string;\n    password: string;\n    first_name?: string;\n    last_name?: string;\n  }) => {\n    try {\n      const response = await authService.register(userData);\n\n      if (response.success) {\n        // Optionally log the user in after registration\n        await login(userData.email, userData.password);\n      } else {\n        throw new Error(response.message || 'Registration failed');\n      }\n    } catch (error) {\n      // Ensure authentication state is properly reset on registration failure\n      setUser(null);\n      setIsAuthenticated(false);\n      throw error;\n    }\n  };\n\n  const logout = async () => {\n    try {\n      await authService.logout();\n    } catch (error) {\n      console.error('Logout error:', error);\n      // Even if server logout fails, clear local state\n    } finally {\n      // Always clear the local state after logout attempt\n      setUser(null);\n      setIsAuthenticated(false);\n      localStorage.removeItem('access_token');\n    }\n  };\n\n  const getCurrentUser = async () => {\n    try {\n      const currentUser = await authService.getCurrentUser();\n      setUser(currentUser);\n      setIsAuthenticated(true);\n      return currentUser; // Return the user data for calling functions to use\n    } catch (error) {\n      console.error('Failed to get current user:', error);\n      setUser(null);\n      setIsAuthenticated(false);\n      localStorage.removeItem('access_token');\n      throw error; // Re-throw the error so calling functions can handle it\n    }\n  };\n\n  const value = {\n    user,\n    loading,\n    isAuthenticated,\n    login,\n    register,\n    logout,\n    getCurrentUser,\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// Custom hook to use the auth context\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n\n  return context;\n};"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;;;;;;AAmBA,qBAAqB;AACrB,MAAM,4BAAc,IAAA,oHAAa,EAA8B;AAOxD,MAAM,eAA4C,CAAC,EAAE,QAAQ,EAAE;IACpE,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,+GAAQ,EAAc;IAC9C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,+GAAQ,EAAU;IAChD,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,IAAA,+GAAQ,EAAU;IAEhE,iDAAiD;IACjD,IAAA,gHAAS,EAAC;QACR,MAAM,kBAAkB;YACtB,IAAI;gBACF,IAAI,uIAAW,CAAC,eAAe,IAAI;oBACjC,MAAM;oBACN,mBAAmB;gBACrB,OAAO;oBACL,0DAA0D;oBAC1D,mBAAmB;gBACrB;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,sBAAsB;gBACpC,0BAA0B;gBAC1B,aAAa,UAAU,CAAC;gBACxB,mEAAmE;gBACnE,mBAAmB;gBACnB,QAAQ;YACV,SAAU;gBACR,WAAW;YACb;QACF;QAEA;IACF,GAAG,EAAE;IAEL,MAAM,QAAQ,OAAO,OAAe;QAClC,IAAI;YACF,MAAM,WAAW,MAAM,uIAAW,CAAC,KAAK,CAAC,OAAO;YAEhD,IAAI,SAAS,OAAO,EAAE;gBACpB,QAAQ,SAAS,IAAI,CAAC,IAAI;gBAC1B,mBAAmB;YACrB,OAAO;gBACL,MAAM,IAAI,MAAM,SAAS,OAAO,IAAI;YACtC;QACF,EAAE,OAAO,OAAO;YACd,iEAAiE;YACjE,QAAQ;YACR,mBAAmB;YACnB,MAAM;QACR;IACF;IAEA,MAAM,WAAW,OAAO;QAMtB,IAAI;YACF,MAAM,WAAW,MAAM,uIAAW,CAAC,QAAQ,CAAC;YAE5C,IAAI,SAAS,OAAO,EAAE;gBACpB,gDAAgD;gBAChD,MAAM,MAAM,SAAS,KAAK,EAAE,SAAS,QAAQ;YAC/C,OAAO;gBACL,MAAM,IAAI,MAAM,SAAS,OAAO,IAAI;YACtC;QACF,EAAE,OAAO,OAAO;YACd,wEAAwE;YACxE,QAAQ;YACR,mBAAmB;YACnB,MAAM;QACR;IACF;IAEA,MAAM,SAAS;QACb,IAAI;YACF,MAAM,uIAAW,CAAC,MAAM;QAC1B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iBAAiB;QAC/B,iDAAiD;QACnD,SAAU;YACR,oDAAoD;YACpD,QAAQ;YACR,mBAAmB;YACnB,aAAa,UAAU,CAAC;QAC1B;IACF;IAEA,MAAM,iBAAiB;QACrB,IAAI;YACF,MAAM,cAAc,MAAM,uIAAW,CAAC,cAAc;YACpD,QAAQ;YACR,mBAAmB;YACnB,OAAO,aAAa,oDAAoD;QAC1E,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,QAAQ;YACR,mBAAmB;YACnB,aAAa,UAAU,CAAC;YACxB,MAAM,OAAO,wDAAwD;QACvE;IACF;IAEA,MAAM,QAAQ;QACZ;QACA;QACA;QACA;QACA;QACA;QACA;IACF;IAEA,qBACE,qKAAC,YAAY,QAAQ;QAAC,OAAO;kBAC1B;;;;;;AAGP;AAGO,MAAM,UAAU;IACrB,MAAM,UAAU,IAAA,iHAAU,EAAC;IAE3B,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 331, "column": 0}, "map": {"version":3,"sources":["file:///home/huzaifa/Hackathon/Todo-app/frontend/src/services/api.ts"],"sourcesContent":["import axios from 'axios';\nimport { Task } from '../types/task';\n\n// Create an axios instance with base configuration\nconst apiClient = axios.create({\n  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',\n  timeout: 10000, // 10 seconds timeout\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Request interceptor to add auth token to requests\napiClient.interceptors.request.use(\n  (config) => {\n    // Check if we're in the browser (not server-side)\n    if (typeof window !== 'undefined' && typeof localStorage !== 'undefined') {\n      const token = localStorage.getItem('access_token');\n\n      if (token) {\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n      // If no token, let the request proceed without authorization\n      // The backend will return 401 which will be handled by response interceptor\n      // This avoids redirect loops during page initialization\n    }\n\n    return config;\n  },\n  (error) => {\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor to handle common errors\napiClient.interceptors.response.use(\n  (response) => {\n    return response;\n  },\n  (error) => {\n    // Handle specific error cases\n    if (error.response?.status === 401) {\n      // Token might be expired, remove invalid token\n      localStorage.removeItem('access_token');\n      // Redirect to login page\n      if (typeof window !== 'undefined') {\n        window.location.href = '/login';\n      }\n    }\n\n    return Promise.reject(error);\n  }\n);\n\n// Task-related API functions\nexport const taskApi = {\n  // Get all tasks for the authenticated user\n  getTasks: async (params?: {\n    status?: string;\n    priority?: string;\n    limit?: number;\n    offset?: number;\n  }) => {\n    const response = await apiClient.get('/api/v1/tasks', { params });\n    return response.data;\n  },\n\n  // Create a new task\n  createTask: async (taskData: Partial<Task>) => {\n    const response = await apiClient.post('/api/v1/tasks', taskData);\n    return response.data;\n  },\n\n  // Get a specific task by ID\n  getTaskById: async (taskId: string) => {\n    const response = await apiClient.get(`/api/v1/tasks/${taskId}`);\n    return response.data;\n  },\n\n  // Update a task (full update)\n  updateTask: async (taskId: string, taskData: Partial<Task>) => {\n    const response = await apiClient.put(`/api/v1/tasks/${taskId}`, taskData);\n    return response.data;\n  },\n\n  // Update a task (partial update)\n  patchTask: async (taskId: string, taskData: Partial<Task>) => {\n    const response = await apiClient.patch(`/api/v1/tasks/${taskId}`, taskData);\n    return response.data;\n  },\n\n  // Delete a task\n  deleteTask: async (taskId: string) => {\n    const response = await apiClient.delete(`/api/v1/tasks/${taskId}`);\n    return response.data;\n  }\n};\n\nexport default apiClient;"],"names":[],"mappings":";;;;;;AAAA;;;;;;AAGA,mDAAmD;AACnD,MAAM,YAAY,qHAAK,CAAC,MAAM,CAAC;IAC7B,SAAS,6DAAmC;IAC5C,SAAS;IACT,SAAS;QACP,gBAAgB;IAClB;AACF;AAEA,oDAAoD;AACpD,UAAU,YAAY,CAAC,OAAO,CAAC,GAAG,CAChC,CAAC;IACC,kDAAkD;IAClD;;IAWA,OAAO;AACT,GACA,CAAC;IACC,OAAO,QAAQ,MAAM,CAAC;AACxB;AAGF,+CAA+C;AAC/C,UAAU,YAAY,CAAC,QAAQ,CAAC,GAAG,CACjC,CAAC;IACC,OAAO;AACT,GACA,CAAC;IACC,8BAA8B;IAC9B,IAAI,MAAM,QAAQ,EAAE,WAAW,KAAK;QAClC,+CAA+C;QAC/C,aAAa,UAAU,CAAC;QACxB,yBAAyB;QACzB;;IAGF;IAEA,OAAO,QAAQ,MAAM,CAAC;AACxB;AAIK,MAAM,UAAU;IACrB,2CAA2C;IAC3C,UAAU,OAAO;QAMf,MAAM,WAAW,MAAM,UAAU,GAAG,CAAC,iBAAiB;YAAE;QAAO;QAC/D,OAAO,SAAS,IAAI;IACtB;IAEA,oBAAoB;IACpB,YAAY,OAAO;QACjB,MAAM,WAAW,MAAM,UAAU,IAAI,CAAC,iBAAiB;QACvD,OAAO,SAAS,IAAI;IACtB;IAEA,4BAA4B;IAC5B,aAAa,OAAO;QAClB,MAAM,WAAW,MAAM,UAAU,GAAG,CAAC,CAAC,cAAc,EAAE,QAAQ;QAC9D,OAAO,SAAS,IAAI;IACtB;IAEA,8BAA8B;IAC9B,YAAY,OAAO,QAAgB;QACjC,MAAM,WAAW,MAAM,UAAU,GAAG,CAAC,CAAC,cAAc,EAAE,QAAQ,EAAE;QAChE,OAAO,SAAS,IAAI;IACtB;IAEA,iCAAiC;IACjC,WAAW,OAAO,QAAgB;QAChC,MAAM,WAAW,MAAM,UAAU,KAAK,CAAC,CAAC,cAAc,EAAE,QAAQ,EAAE;QAClE,OAAO,SAAS,IAAI;IACtB;IAEA,gBAAgB;IAChB,YAAY,OAAO;QACjB,MAAM,WAAW,MAAM,UAAU,MAAM,CAAC,CAAC,cAAc,EAAE,QAAQ;QACjE,OAAO,SAAS,IAAI;IACtB;AACF;uCAEe","debugId":null}},
    {"offset": {"line": 416, "column": 0}, "map": {"version":3,"sources":["file:///home/huzaifa/Hackathon/Todo-app/frontend/src/context/TaskContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport { Task } from '../types/task';\nimport { taskApi } from '../services/api';\n\n// Define the shape of our task context\ninterface TaskContextType {\n  tasks: Task[];\n  loading: boolean;\n  error: string | null;\n  fetchTasks: (params?: { status?: string; priority?: string; limit?: number; offset?: number }) => Promise<void>;\n  createTask: (taskData: Partial<Task>) => Promise<void>;\n  updateTask: (taskId: string, taskData: Partial<Task>) => Promise<void>;\n  patchTask: (taskId: string, taskData: Partial<Task>) => Promise<void>;\n  deleteTask: (taskId: string) => Promise<void>;\n}\n\n// Create the context\nconst TaskContext = createContext<TaskContextType | undefined>(undefined);\n\n// Define action types for the reducer\ntype TaskAction =\n  | { type: 'FETCH_TASKS_START' }\n  | { type: 'FETCH_TASKS_SUCCESS'; payload: Task[] }\n  | { type: 'FETCH_TASKS_ERROR'; payload: string }\n  | { type: 'CREATE_TASK_SUCCESS'; payload: Task }\n  | { type: 'UPDATE_TASK_SUCCESS'; payload: Task }\n  | { type: 'DELETE_TASK_SUCCESS'; payload: string }\n  | { type: 'TASK_ERROR'; payload: string };\n\n// Reducer function\nconst taskReducer = (state: { tasks: Task[]; loading: boolean; error: string | null }, action: TaskAction) => {\n  switch (action.type) {\n    case 'FETCH_TASKS_START':\n      return {\n        ...state,\n        loading: true,\n        error: null\n      };\n    case 'FETCH_TASKS_SUCCESS':\n      return {\n        ...state,\n        loading: false,\n        tasks: action.payload,\n        error: null\n      };\n    case 'FETCH_TASKS_ERROR':\n      return {\n        ...state,\n        loading: false,\n        error: action.payload\n      };\n    case 'CREATE_TASK_SUCCESS':\n      return {\n        ...state,\n        loading: false,\n        tasks: [...state.tasks, action.payload],\n        error: null\n      };\n    case 'UPDATE_TASK_SUCCESS':\n      return {\n        ...state,\n        loading: false,\n        tasks: state.tasks.map(task =>\n          task.id === action.payload.id ? action.payload : task\n        ),\n        error: null\n      };\n    case 'DELETE_TASK_SUCCESS':\n      return {\n        ...state,\n        loading: false,\n        tasks: state.tasks.filter(task => task.id !== action.payload),\n        error: null\n      };\n    case 'TASK_ERROR':\n      return {\n        ...state,\n        loading: false,\n        error: action.payload\n      };\n    default:\n      return state;\n  }\n};\n\n// Create the provider component\ninterface TaskProviderProps {\n  children: React.ReactNode;\n}\n\nexport const TaskProvider: React.FC<TaskProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(taskReducer, {\n    tasks: [],\n    loading: false,\n    error: null\n  });\n\n  const fetchTasks = async (params?: { status?: string; priority?: string; limit?: number; offset?: number }) => {\n    try {\n      dispatch({ type: 'FETCH_TASKS_START' });\n      const response = await taskApi.getTasks(params);\n      dispatch({ type: 'FETCH_TASKS_SUCCESS', payload: response.data.tasks });\n    } catch (error: any) {\n      dispatch({ type: 'FETCH_TASKS_ERROR', payload: error.message || 'Failed to fetch tasks' });\n    }\n  };\n\n  const createTask = async (taskData: Partial<Task>) => {\n    try {\n      const response = await taskApi.createTask(taskData);\n      dispatch({ type: 'CREATE_TASK_SUCCESS', payload: response.data.task });\n    } catch (error: any) {\n      dispatch({ type: 'TASK_ERROR', payload: error.message || 'Failed to create task' });\n    }\n  };\n\n  const updateTask = async (taskId: string, taskData: Partial<Task>) => {\n    try {\n      // Optimistic update: update the task in the UI immediately\n      dispatch({\n        type: 'UPDATE_TASK_SUCCESS',\n        payload: { ...state.tasks.find(t => t.id === taskId), ...taskData } as Task\n      });\n\n      const response = await taskApi.updateTask(taskId, taskData);\n      dispatch({ type: 'UPDATE_TASK_SUCCESS', payload: response.data.task });\n    } catch (error: any) {\n      dispatch({ type: 'TASK_ERROR', payload: error.message || 'Failed to update task' });\n      // Optionally revert the optimistic update if it failed\n      fetchTasks(); // Refresh tasks from server\n    }\n  };\n\n  // Add patchTask function for partial updates\n  const patchTask = async (taskId: string, taskData: Partial<Task>) => {\n    try {\n      // Optimistic update: update the task in the UI immediately\n      dispatch({\n        type: 'UPDATE_TASK_SUCCESS',\n        payload: { ...state.tasks.find(t => t.id === taskId), ...taskData } as Task\n      });\n\n      const response = await taskApi.patchTask(taskId, taskData);\n      dispatch({ type: 'UPDATE_TASK_SUCCESS', payload: response.data.task });\n    } catch (error: any) {\n      dispatch({ type: 'TASK_ERROR', payload: error.message || 'Failed to update task' });\n      // Optionally revert the optimistic update if it failed\n      fetchTasks(); // Refresh tasks from server\n    }\n  };\n\n  const deleteTask = async (taskId: string) => {\n    try {\n      await taskApi.deleteTask(taskId);\n      dispatch({ type: 'DELETE_TASK_SUCCESS', payload: taskId });\n    } catch (error: any) {\n      dispatch({ type: 'TASK_ERROR', payload: error.message || 'Failed to delete task' });\n    }\n  };\n\n  // Fetch tasks on initial load\n  useEffect(() => {\n    fetchTasks();\n  }, []);\n\n  const value = {\n    tasks: state.tasks,\n    loading: state.loading,\n    error: state.error,\n    fetchTasks,\n    createTask,\n    updateTask,\n    patchTask,\n    deleteTask\n  };\n\n  return (\n    <TaskContext.Provider value={value}>\n      {children}\n    </TaskContext.Provider>\n  );\n};\n\n// Custom hook to use the task context\nexport const useTaskContext = (): TaskContextType => {\n  const context = useContext(TaskContext);\n\n  if (!context) {\n    throw new Error('useTaskContext must be used within a TaskProvider');\n  }\n\n  return context;\n};"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 627, "column": 0}, "map": {"version":3,"sources":["file:///home/huzaifa/Hackathon/Todo-app/frontend/src/pages/_app.tsx"],"sourcesContent":["import React from 'react';\nimport { AppProps } from 'next/app';\nimport { AuthProvider } from '../context/AuthContext';\nimport { TaskProvider } from '../context/TaskContext';\nimport '../styles/globals.css';\n\nfunction MyApp({ Component, pageProps }: AppProps) {\n  return (\n    <AuthProvider>\n      <TaskProvider>\n        <Component {...pageProps} />\n      </TaskProvider>\n    </AuthProvider>\n  );\n}\n\nexport default MyApp;"],"names":[],"mappings":";;;;;AAEA;AACA;;;;;;;;;;AAGA,SAAS,MAAM,EAAE,SAAS,EAAE,SAAS,EAAY;IAC/C,qBACE,qKAAC,mJAAY;kBACX,cAAA,qKAAC,mJAAY;sBACX,cAAA,qKAAC;gBAAW,GAAG,SAAS;;;;;;;;;;;;;;;;AAIhC;uCAEe","debugId":null}}]
}